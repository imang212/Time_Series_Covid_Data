---
title: "Analýza covid dat"
author: "Patrik Poklop, Tomáš Ladislav Kotek"
format: html
editor: visual
---

```{=html}
<style>
#quarto-content {
  display: flex;
  align-content: center;
}
main {
  max-width: 1000px;
  margin-left: auto;
  margin-right: auto;
}
</style>
```

# Analýza covid dat na časové řady

```{r echo=FALSE, include=FALSE}
#Načtení potřebných knihoven
library(tidyverse)
library(lubridate)
library(forecast)
library(tseries)
library(stats)
library(corrplot)
library(gridExtra)
library(TTR)
library(seasonal)
library(vars)

Sys.setlocale("LC_TIME", "C")

#Načtení dat
data <- read.csv("covid_timeseries.csv")

knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, fig.width = 40, fig.height = 8)
```

## Úvod

V této analýze se zaměřujem na hledání optimálního modelu pro časovou řadu COVID-19 dat od 5.1.2020 do 8.4.2024. Cílem je otestovat různé přístupy k modelování časových řad a najít ten, který nejlépe popisuje data a poskytuje nejpřesnější predikce.

Analýza postupu je systematicky přes několik kroků: Explorativní analýza - grafické zobrazení a identifikace základních charakteristik:

-   Dekompozice - rozdělení řady na trend, sezónní a náhodnou složku

-   Funkční modelování - hledání matematické funkce popisující trend a sezónnost

-   SARIMA modelování - autoregresní přístup zachycující časovou závislost

-   Multivariátní modelování - zahrnutí vlivu ostatních proměnných

-   Srovnání a validace - výběr nejlepšího modelu na základě kritérií

Jako hlavní řadu jsme zvolili new_cases(nové případy COVID-19), protože:

-   Má výrazný dlouhodobý trend (růst během pandemie).

-   Vykazuje sezónní chování (vyšší hodnoty v zimních měsících).

-   Je klíčovou metrikou pro epidemiologické sledování.

-   Má dostupná kvalitní data bez příliš mnoha chybějících hodnot.

## Převod dat na časovou řadu

```{r}
# Převod datumu na správný formát
data$date <- as.Date(data$date)

# Kontrola chybějících hodnot v new_cases
cat("\nChybějící hodnoty v new_cases:\n")
missing_summary <- sapply(data$new_cases, function(x) sum(is.na(x)))
print(head(missing_summary[missing_summary > 0]))

cat("\nChybějící hodnoty v dates:\n")
missing_summary <- sapply(data$date, function(x) sum(is.na(x)))
print(head(missing_summary[missing_summary > 0]))

# Kontrola new_cases sloupce
cat("\nSouhrn new_cases sloupce:\n")
print(summary(data$new_cases))

# Odstranění řádků s chybějícími hodnotami v new_cases
original_rows <- nrow(data)
data <- data[!is.na(data$new_cases), ]
cat("\nOdstraněno", original_rows - nrow(data), "řádků s chybějícími hodnotami v new_cases\n")

# Vytvoření měsíc-rok proměnné
data$year_month <- format(data$date, "%Y-%m")
data$year <- as.numeric(format(data$date, "%Y"))
data$month <- as.numeric(format(data$date, "%m"))

# Agregace na měsíční součty
monthly_data <- data %>%
  group_by(year, month, year_month) %>%
  summarise(
    new_cases = sum(new_cases, na.rm = TRUE),
    new_deaths = sum(new_deaths, na.rm = TRUE),
    stringency_index = mean(stringency_index, na.rm = TRUE),
    hosp_patients = mean(hosp_patients, na.rm = TRUE),
    reproduction_rate = mean(reproduction_rate, na.rm = TRUE),
    date = max(date),  # poslední den měsíce jako reprezentant
    .groups = 'drop'
  ) %>%
  arrange(year, month)

cat("Počet měsíčních pozorování:", nrow(monthly_data), "\n")
cat("Rozsah dat:", range(monthly_data$date), "\n")

data$year <- as.numeric(format(data$date, "%Y"))
data$week <- as.numeric(format(data$date, "%U"))  # týden v roce (0-53)
data$year_week <- paste(data$year, sprintf("%02d", data$week), sep = "-W")

data <- data %>%
  group_by(year, week, year_week) %>%
  summarise(
    new_cases = sum(new_cases, na.rm = TRUE),
    new_deaths = sum(new_deaths, na.rm = TRUE),
    stringency_index = mean(stringency_index, na.rm = TRUE),
    hosp_patients = mean(hosp_patients, na.rm = TRUE),
    reproduction_rate = mean(reproduction_rate, na.rm = TRUE),
    date = max(date),  # poslední den týdne jako reprezentant
    .groups = 'drop'
  ) %>%
  arrange(year, week) %>%
  filter(week > 0)  # odstraníme týden 0 (může být neúplný)
  
# Vytvoření časové řady
cat("Data začínají od: ",as.numeric(format(min(data$date), "%d")) , as.numeric(format(min(data$date), "%m")), as.numeric(format(min(data$date), "%Y")), "\n")
cat("Data končí: ", as.numeric(format(max(data$date), "%d")), as.numeric(format(max(data$date), "%m")),as.numeric(format(max(data$date), "%Y")))
```

Nejdřív než se data převedli na časovou řadu, zkontrolovalo se, jestli nejsou chybějící hodnoty ve sloupcích, které se budou analyzovat. Zkontrovalo se, jestli nejsou v datech mezery, kolik mají pozorování a jaký je v nich rozsah hodnot.

```{r}
tail(data$date, 1)
start_year <- min(monthly_data$year)
start_month <- min(monthly_data$month[monthly_data$year == start_year])

ts_data <- ts(monthly_data$new_cases, start = c(start_year, start_month), frequency = 12)

cat("Počet pozorování:", length(ts_data), "\n")
cat("Rozsah hodnot:", round(range(ts_data, na.rm = TRUE), 2), "\n")
summary(ts_data)
head(ts_data, 20)
tail(ts_data, 20)


```

Vytvořili jsme časovou řadu v určitém daném rozmezí.

## Grafické zobrazení řady

```{r}
# Grafické zobrazení hlavní řady
p1 <- ggplot(monthly_data, aes(x = date, y = new_cases)) +
  geom_line(color = "steelblue", alpha = 0.7) +
  geom_smooth(method = "loess", color = "red", se = FALSE) +
  labs(title = "Vývoj nových případů COVID-19",
       x = "Datum", y = "Počet nových případů",
       subtitle = "Měsíční agregace denních dat s trendem (červená linie)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Boxplot podle měsíců pro identifikaci sezónnosti
p2 <- ggplot(monthly_data, aes(x = factor(month), y = new_cases)) +
  geom_boxplot(fill = "lightblue", alpha = 0.7) +
  geom_point(alpha = 0.4, position = position_jitter(width = 0.2)) +
  scale_x_discrete(labels = month.abb) +
  labs(title = "Sezónní rozdělení měsíčních případů",
       x = "Měsíc", y = "Počet nových případů") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

grid.arrange(p1, p2, ncol = 1)
```

## Dekompozice a identifikace trendu

#### Dekompozice časové řady

Dekompozice umožňuje pochopit strukturu dat, identifikuje sílu trendové vs. sezónní složky a pomáhá při výběru vhodného typu modelu (aditivní vs. multiplikativní). STL dekompozice je robustní, flexibilní metoda vhodná pro dlouhé časové řady.

```{r}
# STL dekompozice
stl_decomp <- stl(ts_data, s.window = "periodic", t.window = NULL, robust = TRUE)
plot(stl_decomp, main = "STL dekompozice časové řady nových případů")
```

#### Identifikace trendu pomocí vyhlazení

-   MA(4): Měsíční vyhlazení - zobrazí střednědobé trendy
-   MA(52): Roční vyhlazení - zachytí dlouhodobý trend
-   Exponenciální vyhlazení: Dává vyšší váhu novějším pozorováním, vhodné pro predikci

Výsledky říkají, která metoda nejlépe zachycuje základní trend, jak silné jsou krátkodobé vs. dlouhodobé fluktuace, zda je trend stabilní nebo se mění v čase.

```{r}
start_week <- min(data$week[data$year == start_year])
ts_weekly_data <- ts(data$new_cases, start = c(start_year, start_week), frequency = 52)

# Klouzavé průměry různých řádů
ma_4 <- SMA(data$new_cases, n = 4) 
ma_52 <- SMA(data$new_cases, n = 52) 

# Exponenciální vyrovnání - jednodušší přístup
exp_smooth_model <- HoltWinters(ts_weekly_data, gamma = FALSE)

# Vytvoříme jednoduché exponenciální vyhlazení pomocí ETS
ets_model <- ets(ts_weekly_data, model = "AAN", damped = FALSE)
exp_smooth_fitted <- fitted(ets_model)

# Zajistíme stejnou délku (ETS vrací stejnou délku jako originální data)
n_obs <- length(data$new_cases)

# Pokud je exp_smooth_fitted kratší, doplníme NA na začátek
if(length(exp_smooth_fitted) < n_obs) {
  exp_smooth_full <- c(rep(NA, n_obs - length(exp_smooth_fitted)), 
                       as.numeric(exp_smooth_fitted))
} else {
  exp_smooth_full <- as.numeric(exp_smooth_fitted[1:n_obs])
}

# Grafické srovnání - pouze metody, které máme
trend_data <- data.frame(
  date = data$date,
  original = data$new_cases,
  ma_4 = ma_4,
  ma_52 = ma_52,
  exp_smooth = exp_smooth_full
)

# Přidáme exponenciální vyhlazení
trend_data$exp_smooth <- exp_smooth_full

trend_plot <- trend_data %>%
  pivot_longer(cols = -date, names_to = "method", values_to = "value") %>%
  filter(!is.na(value)) %>%  # Odfiltrujeme NA hodnoty
  ggplot(aes(x = date, y = value, color = method)) +
  geom_line(alpha = 0.7, size = 0.65) +
  scale_color_manual(values = c("original" = "gray50", "ma_4" = "blue", "ma_52" = "red", "exp_smooth" = "purple"),
                     name = "Metoda",
                     labels = c("original" = "Originální data", 
                                "ma_4" = "MA(4)", 
                                "ma_52" = "MA(52)", "exp_smooth" = "Exp. vyhlazení")) +
  labs(title = "Srovnání metod vyhlazení trendu",
       x = "Datum", y = "Hodnota") +
  theme_minimal() +
  theme(legend.position = "bottom")

print(trend_plot)

# Analýza trendové složky
trend_component <- stl_decomp$time.series[,"trend"]
cat("Souhrn trendové složky:\n")
print(summary(trend_component))

# Analýza sezónní složky
seasonal_component <- stl_decomp$time.series[,"seasonal"]
cat("\nSouhrn sezónní složky:\n")
print(summary(seasonal_component))
```

## Hledání optimálního funkčního modelu (trend + sezónnost)

Testování různých modelů s kombinacemi, jejich srovnání a grafické zobrazení fitování.

```{r}
# Příprava dat pro regresní model
data$t <- 1:nrow(data)
data$sin_365 <- sin(2 * pi * data$t / 52)
data$cos_365 <- cos(2 * pi * data$t / 52)
data$sin_7 <- sin(2 * pi * data$t / 4)
data$cos_7 <- cos(2 * pi * data$t / 4)
data$sin_1 <- sin(2 * pi * data$t / 1)
data$cos_1 <- cos(2 * pi * data$t / 1)

# Model 1: Lineární trend + roční sezónnost
model1 <- lm(new_cases ~ t + sin_365 + cos_365, data = data)
# Model 2: Polynomiální trend + roční sezónnost
model2 <- lm(new_cases ~ poly(t, 2) + sin_365 + cos_365, data = data)
# Model 3: Lineární trend + roční + měsíční sezónnost
model3 <- lm(new_cases ~ t + sin_365 + cos_365 + sin_7 + cos_7, data = data)
# Model 4: Polynomiální trend + roční + měsíční sezónnost
model4 <- lm(new_cases ~ poly(t, 2) + sin_365 + cos_365 + sin_7 + cos_7, data = data)
# Model 5: Polynomiální trend + roční + měsíční + týdenní sezónnost
model5 <- lm(new_cases ~ poly(t, 2) + sin_365 + cos_365 + sin_7 + cos_7 + sin_1 + cos_1, data = data)
# Model 6: Polynomiální trend + roční + týdenní sezónnost
model6 <- lm(new_cases ~ poly(t, 2) + sin_365 + cos_365 + sin_1 + cos_1, data = data)

# Srovnání modelů
models <- list(model1, model2, model3, model4, model5, model6)
model_names <- c("Lin+Roční", "Poly+Roční", "Lin+Roční+Měsíční", "Poly+Roční+Měsíční", "Poly+Roční+Měsíční+Týdenní", "Poly+Roční+Týdenní")

# AIC a BIC srovnání
comparison <- data.frame(
  Model = model_names,
  AIC = sapply(models, AIC),
  BIC = sapply(models, BIC),
  R_squared = sapply(models, function(x) summary(x)$r.squared)
)
print(comparison)

# Nejlepší model podle AIC
best_func_model <- models[[which.min(comparison$AIC)]]
print(summary(best_func_model))

# Grafické zobrazení fitování
data$fitted_func <- fitted(best_func_model)
ggplot(data, aes(x = date)) +
  geom_line(aes(y = new_cases), color = "black", alpha = 0.6, size = 0.5) +
  geom_line(aes(y = fitted_func), color = "red", size = 1) +
  labs(title = "Nejlepší funkční model",
       x = "Datum", y = "Počet případů",
       subtitle = paste("Model:", model_names[which.min(comparison$AIC)])) +
  theme_minimal()
```

Nejlepší funkční model podle AIC je model s polynomiálním trendem a roční sezónností. Model vysvětluje značnou část variability dat.

## Hledání optimálního SARIMA modelu

#### Kontrola stacionarity

**ADF test**: Testuje přítomnost jednotkového kořene.

**KPSS test**: Testuje stacionaritu kolem trendu. Pokud je řada nestacionární, aplikujeme diferenciaci.

**Stacionární řada**: denní změny (rozdíly) těchto počtů, kolísají kolem nuly bez trendu

**Nestacionární řada**: počty covidových případů, mají trend (rostou/klesají), sezónnost (vlny).

```{r}
# Kontrola stacionarity
adf_test <- adf.test(ts_data)
print(paste("ADF test p-hodnota:", round(adf_test$p.value, 4)))
# KPSS test stacionarity
kpss_test <- kpss.test(ts_data)
print(paste("KPSS test p-hodnota:", round(kpss_test$p.value, 4)))
```

ADF a KPSS testy říkají, že řada je nestacionární, proto se dělá diferenciace. Řada má sezónní trend.

#### PACF a ACF grafy

**ACF (Autokorelační funkce)**: Ukazuje míru korelace mezi hodnotami časové řady a jejími zpožděnými verzemi (lagy). Pokud je ACF výrazná u několika lagů, znamená to, že minulost silně ovlivňuje současnost. Postupný pokles ACF může naznačovat MA (moving average) proces.

**PACF (Parciální ACF)**: Ukazuje korelaci mezi hodnotami časové řady a jejich lagy po odečtení vlivu mezilehlých lagů. Výrazná hodnota PACF na určitém lagu (např. lag 2) znamená, že tento lag má přímý vliv na současnost. Pokud PACF náhle klesne po určitém lagu, může to naznačovat AR (Autoregressive) proces.

```{r}
# ACF a PACF grafy
par(mfrow = c(2,1))
acf(ts_data, main = "ACF původní řady", lag.max = 100)
pacf(ts_data, main = "PACF původní řady", lag.max = 100)

# Diferenciace pokud je potřeba
if(adf_test$p.value > 0.05) {
  ts_diff <- diff(ts_data)
  adf_diff <- adf.test(ts_diff)
  print(paste("ADF test diferencované řady:", round(adf_diff$p.value, 4)))
  
  par(mfrow = c(2,1))
  acf(ts_diff, main = "ACF diferencované řady", lag.max = 100)
  pacf(ts_diff, main = "PACF diferencované řady", lag.max = 100)
} else {
  ts_diff <- ts_data
}
```

Data nevykazují silnou závislost na minulých hodnotách (kromě jedné slabé záporné na lag 1). To by mohlo znamenat, že jednoduchý model (např. jen AR(1) nebo dokonce obyčejný průměr) už bude docela dostačující.

#### Testování SARIMA kombinací

```{r}
cat("Hledání vhodné SARIMA kombinace...\n")
(auto_sarima_a <- auto.arima(ts_data, seasonal = TRUE)) #sezonní diference Zt = 0.004 + 0156*Zt-1 + 0.09*Et-1 + 0.11*Et-2 - 0.53Zt-1
BIC(auto_sarima_a)
#(auto_sarima_b <- auto.arima(ts_data, ic = "bic"))

period <- 52

selected_sarima <- tryCatch({
  arima(ts_weekly_data, 
        order = c(0, 0, 0),
        seasonal = list(order = c(0, 0, 0), period = period))
}, error = function(e) {
  cat("Hlavní SARIMA model selhal:", e$message, "\n")
  # Jednodušší fallback
  arima(ts_weekly_data, order = c(0, 1, 0))
})
alternative_sarima <- tryCatch({
  arima(ts_weekly_data, 
        order = c(0, 1, 0),
        seasonal = list(order = c(0, 1, 0), period = period))
}, error = function(e) {
  cat("Alternativní model selhal:", e$message, "\n")
  return(NULL)
})

if(!is.null(alternative_sarima)) {
  aic1 <- AIC(selected_sarima)
  aic2 <- AIC(alternative_sarima)
  
  cat("SARIMA(0, 0, 0)x(0, 0, 0)[52] AIC:", round(aic1, 2), "\n")
  cat("SARIMA(0, 0, 1)x(0, 1, 0)[52] AIC:", round(aic2, 2), "\n")
  
  if(aic2 < aic1) {
    final_sarima <- alternative_sarima
    cat("Lepší je alternativní model.\n")
  } else {
    final_sarima <- selected_sarima
    cat("Lepší je původní model.\n")
  }
} else {
  final_sarima <- selected_sarima
  cat("Používám původní SARIMA model pro měsíční data.\n")
}

# Diagnostika residuí
checkresiduals(final_sarima)
```

SARIMA model byl identifikován pomocí automatického vyhledávání. Model zachycuje jak autoregresní chování, tak sezónní komponenty. Diagnostika residuí ukazuje, zda jsou splněny předpoklady modelu.

## Analýza závislosti na jiných řadách

**Křížová korelační funkce** (CCF): Měří korelaci mezi dvěma časovými řadami při různých zpožděních

-   **Pozitivní lag**: Y předchází X (Y ovlivňuje budoucí hodnoty X)

-   **Negativní lag**: X předchází Y (X ovlivňuje budoucí hodnoty Y) Zero lag: Současná korelace

**Testované proměnné**:

-   **new_deaths** - úmrtí (očekáváme zpoždění za případy)

-   **stringency_index** - přísnost opatření (může předcházet změnám v případech)

-   **hosp_patients** - hospitalizace (může následovat za případy)

-   **reproduction_rate** - reprodukční číslo (může předcházet změnám)

```{r}
# Příprava dalších časových řad
other_series <- c("new_deaths", "stringency_index", "hosp_patients", "reproduction_rate")

# Křížová korelace s různými zpožděními
ccf_results <- list()
max_lag <- 4

par(mfrow = c(2,2))
for(i in 1:length(other_series)) {
  y_var <- data[[other_series[i]]]
  y_var <- y_var[!is.na(y_var)]
  x_var <- data$new_cases[1:length(y_var)]
  
  ccf_result <- ccf(x_var, y_var, lag.max = max_lag, 
                    main = paste("CCF:", other_series[i]))
  ccf_results[[other_series[i]]] <- ccf_result
}

# Identifikace významných korelací
significant_lags <- list()
for(series in names(ccf_results)) {
  ccf_vals <- ccf_results[[series]]$acf
  lags <- ccf_results[[series]]$lag
  
  # 95% interval spolehlivosti (přibližně)
  n <- length(data$new_cases)
  ci <- 1.96/sqrt(n)
  
  significant_idx <- which(abs(ccf_vals) > ci)
  if(length(significant_idx) > 0) {
    significant_lags[[series]] <- data.frame(
      lag = lags[significant_idx],
      correlation = ccf_vals[significant_idx]
    )
    print(paste("Významné korelace pro", series, ":"))
    print(head(significant_lags[[series]]))
  }
}

```

## Výsledky

-   **new_deaths × new_deaths**
    -   Korelace na lag 0 i ±1 je pozitivní a nad hranicí významnosti → úmrtí jsou silně závislá na předchozích hodnotách (autoregrese).
    -   Dává smysl použít zpoždění `new_deaths` (např. lag 1) jako vysvětlující proměnnou.
-   **new_deaths × stringency_index**
    -   Korelace je malá, téměř všechny sloupce v intervalu - vládní opatření (stringency_index) nemají okamžitou silnou lineární souvislost s denním počtem úmrtí v krátkém horizontu ±4 dní.
-   **new_deaths × hosp_patients**
    -   Výrazně pozitivní korelace na lag 0 a kladných lagech - počet hospitalizovaných je dobrý prediktor úmrtí i pro několik následujících dní.
    -   Určitě má smysl zahrnout hosp_patients (lag 0 nebo 1) do ARIMAX modelu.
-   **new_deaths × reproduction_rate**
    -   Korelace je kolem nuly, uvnitř CI - reprodukční číslo v takto krátkém horizontu přímo neovlivňuje úmrtí (což dává smysl – efekt se projeví až po týdnech).

## Optimální model s externími regresory (ARIMAX model)

Kombinace časové dynamiky ARIMA s vlivem externích faktorů. Arimax model zachycuje autokorelaci v datech a současně modeluje vliv dalších proměnných. VAR model místo jednosměrného vztahu (X → Y) modelujeme vzájemné ovlivnění všech proměnných.

```{r}
# Příprava zpožděných proměnných na základě CCF analýzy
data$deaths_lag <- c(rep(NA, 1), data$new_deaths[1:(nrow(data)-1)])
data$stringency_lag <- c(rep(NA, 5), data$stringency_index[1:(nrow(data)-5)])
data$hosp_lag <- c(rep(NA, 2), data$hosp_patients[1:(nrow(data)-2)])

# Model s externími regresory
external_vars <- cbind(
  deaths_lag = data$deaths_lag,
  stringency_lag = data$stringency_lag,
  hosp_lag = data$hosp_lag
)

# Odstranění NA hodnot
complete_idx <- complete.cases(cbind(data$new_cases, external_vars))
ts_complete <- ts(data$new_cases[complete_idx], start = c(start_year, start_month), frequency = 365.25)
external_complete <- external_vars[complete_idx, ]

# ARIMAX model
arimax_model <- auto.arima(ts_complete, xreg = external_complete)
print(summary(arimax_model))
length(fitted(arimax_model))

# Srovnání modelů
cat("Srovnání všech modelů: \n")
models_comparison <- data.frame(
  Model = c("Funkční", "SARIMA", "ARIMAX"),
  AIC = c(AIC(best_func_model), AIC(final_sarima), AIC(arimax_model)),
  BIC = c(BIC(best_func_model), BIC(final_sarima), BIC(arimax_model))
)

print(models_comparison)
```

ARIMAX model kombinuje autoregresní chování s vlivem externích proměnných.

#### Kontrola předpokladů regresních modelů

Zde ověříme, zda naše modely splňují předpoklady, jako je nezávislost reziduí, heteroskedasticita (konstantní rozptyl), normalita reziduí a Ljung-Box test.

Při porušení předpokladů se dělá:

-   Autokorelace: Zvýšení řádu ARIMA modelu.

-   Nenormalita: Transformace dat nebo robustní metody.

-   Heteroskedasticita: GARCH modely nebo weighted regression.

```{r}
# Diagnostika residuí pro všechny modely
models_to_check <- list(
  "Funkční" = best_func_model,
  "SARIMA" = final_sarima,
  "ARIMAX" = arimax_model
)

par(mfrow = c(2,2))
for(model_name in names(models_to_check)) {
  model <- models_to_check[[model_name]]
  
  if(inherits(model, "lm")) {
    residuals <- residuals(model)
  } else {
    residuals <- residuals(model)
  }
  
  # ACF residuí
  acf(residuals, main = paste("ACF residuí -", model_name), lag.max = 50)
  # Ljung-Box test
  lb_test <- Box.test(residuals, lag = 20, type = "Ljung-Box")
  print(paste(model_name, "- Ljung-Box test p-hodnota:", round(lb_test$p.value, 4)))
  # Normalita residuí
  
shapiro_test <- shapiro.test(sample(residuals, min(5000, length(residuals))))

  print(paste(model_name, "- Shapiro test p-hodnota:", round(shapiro_test$p.value, 4)))
}

# QQ plots pro normalitu
par(mfrow = c(2,2))
for(model_name in names(models_to_check)) {
  model <- models_to_check[[model_name]]
  residuals <- residuals(model)
  qqnorm(residuals, main = paste("Q-Q plot -", model_name))
  qqline(residuals)
}
```

Kontrola ukazuje, zda jsou splněny základní předpoklady modelů - nezávislost residuí (ACF, Ljung-Box test) a jejich normalita (Shapiro test, Q-Q ploty).

## Predikce budoucích hodnot

Zde otestujeme predikční schopnost jednotlivých modelů a porovnáme jejich výkon na 10 období do budoucna.

Srovnáme Funkční model, SARIMA model a ARIMAX model. Vytvoříme Grafické srovnání modelů a kvantitativní hodnocení.

```{r}
# Predikce na 10 období dopředu
horizon <- 52
# Kontrola kvality modelů před predikcí
cat("Kontrola SARIMA modelu:\n")
cat("Koeficienty:", coef(final_sarima), "\n")
cat("Sigma2:", final_sarima$sigma2, "\n")
cat("Loglik:", final_sarima$loglik, "\n")
# Kontrola časové řady
cat("\nKontrola časové řady pro predikci:\n")
cat("Délka:", length(ts_data), "\n")
cat("Start:", paste(start(ts_data), collapse = ", "), "\n")
cat("Frequency:", frequency(ts_data), "\n")
cat("Posledních 5 hodnot:", tail(ts_data, 5), "\n")

# Funkční model predikce
future_t <- (nrow(data)+1):(nrow(data)+horizon)
future_data <- data.frame(
  t = future_t,
  sin_365 = sin(2 * pi * future_t / 365.25),
  cos_365 = cos(2 * pi * future_t / 365.25),
  sin_7 = sin(2 * pi * future_t / 7),
  cos_7 = cos(2 * pi * future_t / 7)
)
# Jednoduchá predikce bez složitého rozlišování modelů
pred_func <- predict(best_func_model, newdata = future_data, interval = "prediction")
cat("Funkční model - predikce dokončena\n")
# SARIMA predikce
if(is.null(final_sarima) || any(is.na(coef(final_sarima)))) {
  cat("SARIMA model je nevalidní! Vytvářím nový jednoduchý model...\n")
  simple_ts <- ts(data$new_cases[!is.na(data$new_cases)], frequency = 1)
  final_sarima <- tryCatch({
    arima(simple_ts, order = c(1, 1, 1))
  }, error = function(e) {
    cat("I jednoduchý ARIMA selhal:", e$message, "\n")
    arima(simple_ts, order = c(0, 1, 0))  # random walk
  })
}

pred_sarima <- forecast(final_sarima, h = horizon)
cat("SARIMA predikce dokončena\n")

# ARIMAX predikce (potřebujeme budoucí hodnoty externích proměnných)
# Pro zjednodušení použijeme poslední dostupné hodnoty
last_external <- external_complete[nrow(external_complete), , drop = FALSE]
future_external <- matrix(rep(as.numeric(last_external), horizon), 
                          nrow = horizon, byrow = TRUE)

colnames(future_external) <- colnames(external_complete)


cat("Názvy sloupců v trénovacích datech:", colnames(external_complete), "\n")
cat("Názvy sloupců v predikčních datech:", colnames(future_external), "\n")
pred_arimax = forecast(arimax_model, xreg = future_external, h = horizon)
cat("ARIMAX predikce dokončena\n")
```

#### Grafické srovnání a hodnocení modelů

```{r}
tail(data$date, 1)        # poslední datum v datech
```

```{r}
# Grafické zobrazení predikcí
future_dates <- seq(max(data$date) + 1, by = "day", length.out = horizon)

cat("Budoucí data:", as.character(future_dates[1:3]), "...\n")

# === KONTROLA PŘED GRAFEM ===
cat("\n=== FINÁLNÍ KONTROLA ===\n")
cat("Funkční - rozsah:", range(pred_func[,1]), "\n") 
cat("SARIMA - rozsah:", range(pred_sarima$mean), "\n")
cat("ARIMAX - rozsah:", range(pred_arimax$mean), "\n")

# Test na nuly
if(all(pred_sarima$mean == 0)) {
  cat("PROBLÉM: SARIMA predikuje samé nuly!\n")
  cat("Poslední hodnota v časové řadě:", tail(as.numeric(ts_data), 1), "\n")
  cat("Model summary:\n")
  print(summary(final_sarima))
  # Oprava: použij poslední hodnotu
  pred_sarima$mean <- rep(tail(as.numeric(ts_data), 1), horizon)
  pred_sarima$lower[,2] <- pred_sarima$mean * 0.8
  pred_sarima$upper[,2] <- pred_sarima$mean * 1.2
}


# Určíme počet historických pozorování k zobrazení (posledních 24 měsíců nebo méně)
last_n_obs <- 136
cat("Zobrazím posledních", last_n_obs, "měsíčních pozorování\n")
if(nrow(data) < last_n_obs) last_n_obs <- nrow(data);


# Historická data
historical_dates <- tail(data$date, last_n_obs)
historical_values <- tail(data$new_cases, last_n_obs)

# Kontrola, že predikce mají správnou délku a nejsou NA
pred_func_clean <- pred_func[,1]
pred_func_lower <- pred_func[,2] 
pred_func_upper <- pred_func[,3]

pred_sarima_clean <- as.numeric(pred_sarima$mean)
pred_sarima_lower <- as.numeric(pred_sarima$lower[,2])
pred_sarima_upper <- as.numeric(pred_sarima$upper[,2])

pred_arimax_clean <- as.numeric(pred_arimax$mean)
pred_arimax_lower <- as.numeric(pred_arimax$lower[,2])
pred_arimax_upper <- as.numeric(pred_arimax$upper[,2])

# Náhrada NA hodnotami z SARIMA predikce pokud je potřeba
if(any(is.na(pred_func_clean))) {
  cat("Opravuji NA v funkčních predikcích\n")
  pred_func_clean[is.na(pred_func_clean)] <- pred_sarima$mean[is.na(pred_func_clean)]
  pred_func_lower[is.na(pred_func_lower)] <- pred_sarima$lower[is.na(pred_func_lower),2]
  pred_func_upper[is.na(pred_func_upper)] <- pred_sarima$upper[is.na(pred_func_upper),2]
}

# Vytvoření clean dat pro ggplot
plot_data_clean <- data.frame(
  date = c(historical_dates, future_dates),
  actual = c(historical_values, rep(NA, horizon)),
  
  # Funkční model
  func_pred = c(rep(NA, last_n_obs), pred_func_clean),
  func_lower = c(rep(NA, last_n_obs), pred_func_lower),
  func_upper = c(rep(NA, last_n_obs), pred_func_upper),
  
  # SARIMA model  
  sarima_pred = c(rep(NA, last_n_obs), as.numeric(pred_sarima$mean)),
  sarima_lower = c(rep(NA, last_n_obs), as.numeric(pred_sarima$lower[,2])),
  sarima_upper = c(rep(NA, last_n_obs), as.numeric(pred_sarima$upper[,2])),
  
  # ARIMAX model
  arimax_pred = c(rep(NA, last_n_obs), as.numeric(pred_arimax$mean)),
  arimax_lower = c(rep(NA, last_n_obs), as.numeric(pred_arimax$lower[,2])),
  arimax_upper = c(rep(NA, last_n_obs), as.numeric(pred_arimax$upper[,2]))
)

# Kontrola finálních dat
cat("Kontrola plot_data_clean:\n")
cat("Počet řádků:", nrow(plot_data_clean), "\n")
cat("NA v actual:", sum(is.na(plot_data_clean$actual)), "\n")
cat("NA v func_pred:", sum(is.na(plot_data_clean$func_pred)), "\n")
cat("NA v sarima_pred:", sum(is.na(plot_data_clean$sarima_pred)), "\n")

```

```{r}
# Vylepšený graf predikcí
prediction_plot <- ggplot(plot_data_clean, aes(x = date)) +
  # Historická data - body a čáry
  geom_line(aes(y = actual), color = "black", size = 1.2, alpha = 0.8, na.rm = TRUE) +
  geom_point(aes(y = actual), color = "black", size = 2, alpha = 0.7, na.rm = TRUE) +
  # Funkční model
  geom_line(aes(y = func_pred), color = "red", size = 1.2, na.rm = TRUE) +
  geom_point(aes(y = func_pred), color = "red", size = 2, na.rm = TRUE) +
  geom_ribbon(aes(ymin = func_lower, ymax = func_upper), fill = "red", alpha = 0.2, na.rm = TRUE) +
  # SARIMA model
  geom_line(aes(y = sarima_pred), color = "blue", size = 1.2, na.rm = TRUE) +
  geom_point(aes(y = sarima_pred), color = "blue", size = 2, na.rm = TRUE) +
  geom_ribbon(aes(ymin = sarima_lower, ymax = sarima_upper), fill = "blue", alpha = 0.2, na.rm = TRUE) +
  # ARIMAX model
  geom_line(aes(y = arimax_pred), color = "green", size = 1.2, na.rm = TRUE) +
  geom_point(aes(y = arimax_pred), color = "green", size = 2, na.rm = TRUE) +
  geom_ribbon(aes(ymin = arimax_lower, ymax = arimax_upper), fill = "green", alpha = 0.2, na.rm = TRUE) +
  # Vertikální čára oddělující historii od predikcí
  geom_vline(xintercept = max(historical_dates), linetype = "dashed", alpha = 0.7, color = "gray50", size = 1) +
  # Lepší popisky a téma
  labs(title = "Predikce měsíčních nových případů - srovnání modelů", x = "Datum", y = "Počet případů (měsíčně)",
       subtitle = paste("Historická data (černá) | Predikce: Funkční (červená), SARIMA (modrá), ARIMAX (zelená)", "\nPřerušovaná čára označuje konec historických dat")) +
  theme_minimal() +
  theme(legend.position = "none", plot.title = element_text(size = 14, hjust = 0.5, face = "bold"), plot.subtitle = element_text(size = 11, hjust = 0.5),
    axis.text.x = element_text(angle = 45, hjust = 1), panel.grid.minor = element_blank())
#  # Rozumné limity osy y
#  + coord_cartesian(ylim = c(0, max(c(historical_values, #pred_func_clean, pred_sarima, pred_arimax_clean), na.rm = TRUE) * #1.1))

print(prediction_plot)

# Číselný souhrn predikcí
cat("\n=== ČÍSELNÉ PREDIKCE (měsíční hodnoty) ===\n")
predictions_summary <- data.frame(Měsíc = future_dates, Funkční = round(pred_func_clean, 0), SARIMA = round(pred_sarima_clean, 0), ARIMAX = round(pred_arimax_clean, 0))

print("Predikce na příštích 10 měsíců:")
print(predictions_summary)
```

Srovnání ukazuje rozdíly mezi jednotlivými přístupy. SARIMA model ukazuje nejlepší výsledek.

## Závěrečné srovnání a doporučení

Zhodnocení všech testovaných přístupů a formulace doporučení pro praxi.

```{r}
# Finální srovnání všech modelů
final_comparison <- data.frame(
  Model = c("Funkční (trend+sezónost)", "SARIMA", "ARIMAX"),
  AIC = c(AIC(best_func_model), AIC(final_sarima), AIC(arimax_model)),
  BIC = c(BIC(best_func_model), BIC(final_sarima), BIC(arimax_model)),
  Parametrů = c(length(coef(best_func_model)), 
                length(coef(final_sarima)),
                length(coef(arimax_model))),
  RMSE = c(
    sqrt(mean(residuals(best_func_model)^2)),
    sqrt(mean(residuals(final_sarima)^2)),
    sqrt(mean(residuals(arimax_model)^2))
  )
)

print("Finální srovnání modelů:")
print(final_comparison)

# Doporučení nejlepšího modelu
best_model_idx <- which.min(final_comparison$AIC)
best_model_name <- final_comparison$Model[best_model_idx]

cat("\n=== DOPORUČENÍ ===\n")
cat("Nejlepší model podle AIC:", best_model_name, "\n")
cat("AIC:", round(final_comparison$AIC[best_model_idx], 2), "\n")
cat("RMSE:", round(final_comparison$RMSE[best_model_idx], 2), "\n")
```
