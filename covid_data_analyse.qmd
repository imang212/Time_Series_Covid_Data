---
title: "Analýza covid dat"
author: "Patrik Poklop, Tomáš Ladislav Kotek"
format: html
editor: visual
---

```{=html}
<style>
#quarto-content {
  display: flex;
  align-content: center;
}
main {
  max-width: 1000px;
  margin-left: auto;
  margin-right: auto;
}
</style>
```

# Analýza covid dat na časové řady

```{r echo=FALSE, include=FALSE}
#Načtení potřebných knihoven
library(tidyverse)
library(lubridate)
library(forecast)
library(tseries)
library(stats)
library(corrplot)
library(gridExtra)
library(TTR)
library(seasonal)
library(vars)
library(ggplot2)

Sys.setlocale("LC_TIME", "C")

#Načtení dat
data <- read.csv("covid_timeseries.csv")

knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, fig.width = 20, fig.height = 10, 
  fig.retina = 2,        # pro ostřejší grafy
  dpi = 300,             # rozlišení grafů
  dev = "png",           # formát obrázků
  fig.align = "center"   # zarovnání grafů na střed)
)
theme_set(theme_minimal(base_size = 26)) # základní velikost písma
update_geom_defaults("line", list(size = 2)) # výchozí tloušťka čar
update_geom_defaults("point", list(size = 4)) # výchozí velikost bodů
par(cex = 3,           # velikost písma
    cex.axis = 2.5,    # velikost popisků os
    cex.lab = 2.5,     # velikost názvů os
    cex.main = 3)      # velikost hlavního titulku
```

## Úvod

V této analýze se zaměřujem na hledání optimálního modelu pro časovou řadu COVID-19 dat od 5.1.2020 do 8.4.2024. Cílem je otestovat různé přístupy k modelování časových řad a najít ten, který nejlépe popisuje data a poskytuje nejpřesnější predikce.

Analýza postupu je systematicky přes několik kroků: Explorativní analýza - grafické zobrazení a identifikace základních charakteristik:

-   Dekompozice - rozdělení řady na trend, sezónní a náhodnou složku

-   Funkční modelování - hledání matematické funkce popisující trend a sezónnost

-   SARIMA modelování - autoregresní přístup zachycující časovou závislost

-   Multivariátní modelování - zahrnutí vlivu ostatních proměnných

-   Srovnání a validace - výběr nejlepšího modelu na základě kritérií

Jako hlavní řadu jsme zvolili new_cases(nové případy COVID-19), protože:

-   Má výrazný dlouhodobý trend (růst během pandemie).

-   Vykazuje sezónní chování (vyšší hodnoty v zimních měsících).

-   Je klíčovou metrikou pro epidemiologické sledování.

-   Má dostupná kvalitní data bez příliš mnoha chybějících hodnot.

## Převod dat na časovou řadu

```{r}
# Převod datumu na správný formát
data$date <- as.Date(data$date)

# Kontrola chybějících hodnot v new_cases
cat("\nChybějící hodnoty v new_cases:\n")
missing_summary <- sapply(data$new_cases, function(x) sum(is.na(x)))
print(head(missing_summary[missing_summary > 0]))

cat("\nChybějící hodnoty v dates:\n")
missing_summary <- sapply(data$date, function(x) sum(is.na(x)))
print(head(missing_summary[missing_summary > 0]))

# Kontrola new_cases sloupce
cat("\nSouhrn new_cases sloupce:\n")
print(summary(data$new_cases))

# Odstranění řádků s chybějícími hodnotami v new_cases
original_rows <- nrow(data)
data <- data[!is.na(data$new_cases), ]
cat("\nOdstraněno", original_rows - nrow(data), "řádků s chybějícími hodnotami v new_cases\n")

# Vytvoření měsíc-rok proměnné
data$year_month <- format(data$date, "%Y-%m")
data$year <- as.numeric(format(data$date, "%Y"))
data$month <- as.numeric(format(data$date, "%m"))

# Agregace na měsíční součty
monthly_data <- data %>%
  group_by(year, month, year_month) %>%
  summarise(
    new_cases = sum(new_cases, na.rm = TRUE),
    new_deaths = sum(new_deaths, na.rm = TRUE),
    stringency_index = mean(stringency_index, na.rm = TRUE),
    hosp_patients = mean(hosp_patients, na.rm = TRUE),
    reproduction_rate = mean(reproduction_rate, na.rm = TRUE),
    date = max(date),  # poslední den měsíce jako reprezentant
    .groups = 'drop'
  ) %>%
  arrange(year, month)

cat("Počet měsíčních pozorování:", nrow(monthly_data), "\n")
cat("Rozsah dat:", range(monthly_data$date), "\n")

data$year <- as.numeric(format(data$date, "%Y"))
data$week <- as.numeric(format(data$date, "%U"))  # týden v roce (0-53)
data$year_week <- paste(data$year, sprintf("%02d", data$week), sep = "-W")

data <- data %>%
  group_by(year, week, year_week) %>%
  summarise(
    new_cases = sum(new_cases, na.rm = TRUE),
    new_deaths = sum(new_deaths, na.rm = TRUE),
    stringency_index = mean(stringency_index, na.rm = TRUE),
    hosp_patients = mean(hosp_patients, na.rm = TRUE),
    reproduction_rate = mean(reproduction_rate, na.rm = TRUE),
    date = max(date),  # poslední den týdne jako reprezentant
    .groups = 'drop'
  ) %>%
  arrange(year, week) %>%
  filter(week > 0)  # odstraníme týden 0 (může být neúplný)
  
# Vytvoření časové řady
cat("Data začínají od: ",as.numeric(format(min(data$date), "%d")) , as.numeric(format(min(data$date), "%m")), as.numeric(format(min(data$date), "%Y")), "\n")
cat("Data končí: ", as.numeric(format(max(data$date), "%d")), as.numeric(format(max(data$date), "%m")),as.numeric(format(max(data$date), "%Y")))
```

Nejdřív se zkontrolovalo, jestli nejsou chybějící hodnoty ve sloupcích, které by mohly dělat problém při analýze. Zkontrovalo se, jestli nejsou v datech mezery, kolik mají pozorování a jaký je v nich rozsah hodnot. Potom se udělala agregace na měsíční a týdenní součty. Použijeme týdenní agregaci.

**Proč týdenní agregace?:**

-   Eliminuje víkendové efekty v hlášení případů.

-   Snižuje šum v datech způsobený administrativními procesy.

-   Zachovává sezónní vzorce, ale redukuje krátkodobé fluktuace.

```{r}
start_year <- min(monthly_data$year)
#start_month <- min(monthly_data$month[monthly_data$year == start_year])
start_week <- min(data$week[data$year == start_year])

ts_data <- ts(data$new_cases, start = c(start_year, start_week), frequency = 52.18)

cat("Počet pozorování:", length(ts_data), "\n")
cat("Rozsah hodnot:", round(range(ts_data, na.rm = TRUE), 2), "\n")
summary(ts_data)
head(ts_data, 20)
tail(ts_data, 20)
```

Vytvořili jsme časovou řadu s týdenní frekvencí.

## Grafické zobrazení řady

Zobrazíme hlavní řadu pomocí týdenních dat a boxplot graf podle měsíčních dat pro identifikaci sezónnosti.

```{r}
# Grafické zobrazení hlavní řady
p1 <- ggplot(data, aes(x = date, y = new_cases)) +
  geom_line(color = "steelblue", alpha = 0.7) +
  geom_smooth(method = "loess", color = "red", se = FALSE) +
  labs(title = "Vývoj nových případů COVID-19",
       x = "Datum", y = "Počet nových případů",
       subtitle = "Týdenní agregace denních dat s trendem (červená linie)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Boxplot podle měsíců pro identifikaci sezónnosti
p2 <- ggplot(monthly_data, aes(x = factor(month), y = new_cases)) +
  geom_boxplot(fill = "lightblue", alpha = 0.7) +
  geom_point(alpha = 0.4, position = position_jitter(width = 0.2)) +
  scale_x_discrete(labels = month.abb) +
  labs(title = "Sezónní rozdělení měsíčních případů",
       x = "Měsíc", y = "Počet nových případů") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

grid.arrange(p1, p2, ncol = 1)
```

## Dekompozice a identifikace trendu

#### Logaritmická transformace

```{r}
ts_log <- log1p(ts_data)  # log stabilizace
```

**Důvody:**

-   Stabilizuje varianci (heteroskedasticita)

-   Lineární trendy se stávají exponenciálními ve skutečných datech

-   Zlepšuje normalitu reziduí

#### Dekompozice časové řady

Dekompozice umožňuje pochopit strukturu dat, identifikuje sílu trendové vs. sezónní složky a pomáhá při výběru vhodného typu modelu (aditivní vs. multiplikativní).

STL dekompozice je robustní vůči sezónním hodnotám, zvládá změny v sezónních vzorcích a umožňuje flexibilní nastavení trend vs. sezónní komponenty.

```{r}
# STL dekompozice
stl_decomp <- stl(ts_log, s.window = "periodic", t.window = NULL, robust = TRUE)
plot(stl_decomp, main = "STL dekompozice časové řady nových případů")
```

#### Identifikace trendu pomocí vyhlazení

-   MA(4): Měsíční vyhlazení - Zobrazí střednědobé trendy.
-   MA(52): Roční vyhlazení - Zachytí dlouhodobý trend.
-   Exponenciální vyhlazení - Dává vyšší váhu novějším pozorováním, vhodné pro predikci.

Výsledky říkají, která metoda nejlépe zachycuje základní trend, jak silné jsou krátkodobé vs. dlouhodobé fluktuace, zda je trend stabilní nebo se mění v čase.

```{r}
start_week <- min(data$week[data$year == start_year])
ts_weekly_data <- ts(data$new_cases, start = c(start_year, start_week), frequency = 52.18)

# Klouzavé průměry různých řádů
ma_4 <- SMA(data$new_cases, n = 4) 
ma_52 <- SMA(data$new_cases, n = 52.18) 

# Exponenciální vyrovnání - jednodušší přístup
exp_smooth_model <- HoltWinters(ts_weekly_data, gamma = FALSE)

# Vytvoříme jednoduché exponenciální vyhlazení pomocí ETS
ets_model <- ets(ts_weekly_data, model = "AAN", damped = FALSE)
exp_smooth_fitted <- fitted(ets_model)

# Zajistíme stejnou délku (ETS vrací stejnou délku jako originální data)
n_obs <- length(data$new_cases)

# Pokud je exp_smooth_fitted kratší, doplníme NA na začátek
if(length(exp_smooth_fitted) < n_obs) {
  exp_smooth_full <- c(rep(NA, n_obs - length(exp_smooth_fitted)), 
                       as.numeric(exp_smooth_fitted))
} else {
  exp_smooth_full <- as.numeric(exp_smooth_fitted[1:n_obs])
}

# Grafické srovnání - pouze metody, které máme
trend_data <- data.frame(
  date = data$date,
  original = data$new_cases,
  ma_4 = ma_4,
  ma_52 = ma_52,
  exp_smooth = exp_smooth_full
)

# Přidáme exponenciální vyhlazení
trend_data$exp_smooth <- exp_smooth_full

trend_plot <- trend_data %>%
  pivot_longer(cols = -date, names_to = "method", values_to = "value") %>%
  filter(!is.na(value)) %>%  # Odfiltrujeme NA hodnoty
  ggplot(aes(x = date, y = value, color = method)) +
  geom_line(alpha = 0.7, size = 0.65) +
  scale_color_manual(values = c("original" = "gray50", "ma_4" = "blue", "ma_52" = "red", "exp_smooth" = "purple"),
                     name = "Metoda",
                     labels = c("original" = "Originální data", 
                                "ma_4" = "MA(4)", 
                                "ma_52" = "MA(52)", "exp_smooth" = "Exp. vyhlazení")) +
  labs(title = "Srovnání metod vyhlazení trendu",
       x = "Datum", y = "Hodnota") +
  theme_minimal() +
  theme(legend.position = "bottom")

print(trend_plot)

# Analýza trendové složky
trend_component <- stl_decomp$time.series[,"trend"]
cat("Souhrn trendové složky:\n")
print(summary(trend_component))

# Analýza sezónní složky
seasonal_component <- stl_decomp$time.series[,"seasonal"]
cat("\nSouhrn sezónní složky:\n")
print(summary(seasonal_component))
```

## Hledání optimálního funkčního modelu (trend + sezónnost)

Testování různých modelů s kombinacemi, jejich srovnání a grafické zobrazení fitování.

```{r}
# Příprava dat pro regresní model
data$t <- 1:nrow(data)
data$sin_365 <- sin(2 * pi * data$t / 52.18)
data$cos_365 <- cos(2 * pi * data$t / 52.18)
data$sin_7 <- sin(2 * pi * data$t / 4)
data$cos_7 <- cos(2 * pi * data$t / 4)
data$sin_1 <- sin(2 * pi * data$t / 1)
data$cos_1 <- cos(2 * pi * data$t / 1)

# Model 1: Lineární trend + roční sezónnost
model1 <- lm(log1p(new_cases) ~ t + sin_365 + cos_365, data = data)
# Model 2: Polynomiální trend + roční sezónnost
model2 <- lm(log1p(new_cases) ~ poly(t, 2) + sin_365 + cos_365, data = data)
# Model 3: Lineární trend + roční + měsíční sezónnost
model3 <- lm(log1p(new_cases) ~ t + sin_365 + cos_365 + sin_7 + cos_7, data = data)
# Model 4: Polynomiální trend + roční + měsíční sezónnost
model4 <- lm(log1p(new_cases) ~ poly(t, 2) + sin_365 + cos_365 + sin_7 + cos_7, data = data)
# Model 5: Lineární trend + roční + měsíční sezónnost + týdenní sezónnost
model5 <- lm(log1p(new_cases) ~ t + sin_365 + cos_365 + sin_7 + cos_7 + sin_1 + cos_1, data = data)
# Model 6: Polynomiální trend + roční + měsíční + týdenní sezónnost
model6 <- lm(log1p(new_cases) ~ poly(t, 2) + sin_365 + cos_365 + sin_7 + cos_7 + sin_1 + cos_1, data = data)
# Model 7: Lineární trend + roční + týdenní sezónnost
model7 <- lm(log1p(new_cases) ~ t + sin_365 + cos_365 + sin_1 + cos_1, data = data)
# Model 8: Polynomiální trend + roční + týdenní sezónnost
model8 <- lm(log1p(new_cases) ~ poly(t, 2) + sin_365 + cos_365 + sin_1 + cos_1, data = data)

# Srovnání modelů
models <- list(model1, model2, model3, model4, model5, model6, model7, model8)
model_names <- c("Lin+Roční", "Poly+Roční", "Lin+Roční+Měsíční", "Poly+Roční+Měsíční", "Lin+Roční+Měsíční+Týdenní" ,"Poly+Roční+Měsíční+Týdenní", "Lin+Roční+Týdenní", "Poly+Roční+Týdenní")

# AIC a BIC srovnání
comparison <- data.frame(
  Model = model_names,
  AIC = sapply(models, AIC),
  BIC = sapply(models, BIC),
  R_squared = sapply(models, function(x) summary(x)$r.squared)
)
print(comparison)

# Nejlepší model podle AIC
best_func_model <- models[[which.min(comparison$AIC)]]
print(summary(best_func_model))

# Grafické zobrazení fitování
data$fitted_func <-  expm1(fitted(best_func_model))
ggplot(data, aes(x = date)) +
  geom_line(aes(y = new_cases), color = "black", alpha = 0.6, size = 0.5) +
  geom_line(aes(y = fitted_func), color = "red", size = 1) +
  labs(title = "Nejlepší funkční model",
       x = "Datum", y = "Počet případů",
       subtitle = paste("Model:", model_names[which.min(comparison$AIC)])) +
  theme_minimal()
```

Nejlepší funkční model podle AIC je model s polynomiálním trendem a roční sezónností. Model vysvětluje značnou část variability dat.

## Hledání optimálního SARIMA modelu

#### Kontrola stacionarity

**ADF test**: Testuje přítomnost jednotkového kořene.

**KPSS test**: Testuje stacionaritu kolem trendu. Pokud je řada nestacionární, aplikujeme diferenciaci.

**Stacionární řada**: denní změny (rozdíly) těchto počtů, kolísají kolem nuly bez trendu

**Nestacionární řada**: počty covidových případů, mají trend (rostou/klesají), sezónnost (vlny).

```{r}
ts_diff <- diff(ts_log) # 1. diferenciace
# Kontrola stacionarity
adf_test <- adf.test(ts_diff)
print(paste("ADF test p-hodnota:", round(adf_test$p.value, 4)))
# KPSS test stacionarity
kpss_test <- kpss.test(ts_diff)
print(paste("KPSS test p-hodnota:", round(kpss_test$p.value, 4)))
```

ADF a KPSS testy říkají, že řada je nestacionární, proto se dělá diferenciace. Řada má sezónní trend.

#### PACF a ACF grafy

**ACF (Autokorelační funkce)**: Ukazuje míru korelace mezi hodnotami časové řady a jejími zpožděnými verzemi (lagy). Pokud je ACF výrazná u několika lagů, znamená to, že minulost silně ovlivňuje současnost. Postupný pokles ACF může naznačovat MA (moving average) proces.

**PACF (Parciální ACF)**: Ukazuje korelaci mezi hodnotami časové řady a jejich lagy po odečtení vlivu mezilehlých lagů. Výrazná hodnota PACF na určitém lagu (např. lag 2) znamená, že tento lag má přímý vliv na současnost. Pokud PACF náhle klesne po určitém lagu, může to naznačovat AR (Autoregressive) proces.

```{r}
# ACF a PACF grafy
par(mfrow = c(2,1))
acf(ts_data, main = "ACF původní řady", lag.max = 100)
pacf(ts_data, main = "PACF původní řady", lag.max = 100)

# Diferenciace pokud je potřeba
if(adf_test$p.value > 0.05) {
  ts_diff <- diff(ts_data)
  adf_diff <- adf.test(ts_diff)
  print(paste("ADF test diferencované řady:", round(adf_diff$p.value, 4)))
  
  par(mfrow = c(2,1))
  acf(ts_diff, main = "ACF diferencované řady", lag.max = 100)
  pacf(ts_diff, main = "PACF diferencované řady", lag.max = 100)
} else {
  ts_diff <- ts_data
}
```

Data nevykazují silnou závislost na minulých hodnotách (kromě jedné slabé záporné na lag 1). To by mohlo znamenat, že jednoduchý model (např. jen AR(1) nebo dokonce obyčejný průměr) už bude docela dostačující.

#### Testování SARIMA kombinací

```{r}
cat("Hledání vhodné SARIMA kombinace...\n")
(auto_sarima_a <- auto.arima(ts_log, seasonal = TRUE)) #sezonní diference Zt = 0.004 + 0156*Zt-1 + 0.09*Et-1 + 0.11*Et-2 - 0.53Zt-1
BIC(auto_sarima_a)
#(auto_sarima_b <- auto.arima(ts_data, ic = "bic"))
final_sarima <- auto_sarima_a
# Diagnostika residuí
checkresiduals(final_sarima)
```

SARIMA model byl identifikován pomocí automatického vyhledávání. Model zachycuje jak autoregresní chování, tak sezónní komponenty. Diagnostika residuí ukazuje, zda jsou splněny předpoklady modelu.

## Analýza závislosti na jiných řadách

**Křížová korelační funkce** (CCF): Měří korelaci mezi dvěma časovými řadami při různých zpožděních

-   **Pozitivní lag**: Y předchází X (Y ovlivňuje budoucí hodnoty X)

-   **Negativní lag**: X předchází Y (X ovlivňuje budoucí hodnoty Y) Zero lag: Současná korelace

**Testované proměnné**:

-   **new_deaths** - úmrtí (očekáváme zpoždění za případy)

-   **stringency_index** - přísnost opatření (může předcházet změnám v případech)

-   **hosp_patients** - hospitalizace (může následovat za případy)

-   **reproduction_rate** - reprodukční číslo (může předcházet změnám)

```{r}
# Příprava dalších časových řad
other_series <- c("new_deaths", "stringency_index", "hosp_patients", "reproduction_rate")

# Křížová korelace s různými zpožděními
ccf_results <- list()
max_lag <- 4

par(mfrow = c(2,2))
for(i in 1:length(other_series)) {
  y_var <- data[[other_series[i]]]
  y_var <- y_var[!is.na(y_var)]
  x_var <- data$new_cases[1:length(y_var)]
  
  ccf_result <- ccf(x_var, y_var, lag.max = max_lag, 
                    main = paste("CCF:", other_series[i]))
  ccf_results[[other_series[i]]] <- ccf_result
}

# Identifikace významných korelací
significant_lags <- list()
for(series in names(ccf_results)) {
  ccf_vals <- ccf_results[[series]]$acf
  lags <- ccf_results[[series]]$lag
  
  # 95% interval spolehlivosti (přibližně)
  n <- length(data$new_cases)
  ci <- 1.96/sqrt(n)
  
  significant_idx <- which(abs(ccf_vals) > ci)
  if(length(significant_idx) > 0) {
    significant_lags[[series]] <- data.frame(
      lag = lags[significant_idx],
      correlation = ccf_vals[significant_idx]
    )
    print(paste("Významné korelace pro", series, ":"))
    print(head(significant_lags[[series]]))
  }
}

```

## Výsledky

-   **new_deaths × new_deaths**
    -   Korelace na lag 0 i ±1 je pozitivní a nad hranicí významnosti → úmrtí jsou silně závislá na předchozích hodnotách (autoregrese).
    -   Dává smysl použít zpoždění `new_deaths` (např. lag 1) jako vysvětlující proměnnou.
-   **new_deaths × stringency_index**
    -   Korelace je malá, téměř všechny sloupce v intervalu - vládní opatření (stringency_index) nemají okamžitou silnou lineární souvislost s denním počtem úmrtí v krátkém horizontu ±4 dní.
-   **new_deaths × hosp_patients**
    -   Výrazně pozitivní korelace na lag 0 a kladných lagech - počet hospitalizovaných je dobrý prediktor úmrtí i pro několik následujících dní.
    -   Určitě má smysl zahrnout hosp_patients (lag 0 nebo 1) do ARIMAX modelu.
-   **new_deaths × reproduction_rate**
    -   Korelace je kolem nuly, uvnitř CI - reprodukční číslo v takto krátkém horizontu přímo neovlivňuje úmrtí (což dává smysl – efekt se projeví až po týdnech).

## Optimální model s externími regresory (ARIMAX model)

Kombinace časové dynamiky ARIMA s vlivem externích faktorů. Arimax model zachycuje autokorelaci v datech a současně modeluje vliv dalších proměnných.

```{r}
# Příprava zpožděných proměnných na základě CCF analýzy
data$deaths_lag <- c(rep(NA, 1), data$new_deaths[1:(nrow(data)-1)])
data$stringency_lag <- c(rep(NA, 5), data$stringency_index[1:(nrow(data)-5)])
data$hosp_lag <- c(rep(NA, 2), data$hosp_patients[1:(nrow(data)-2)])

# Model s externími regresory
external_vars <- cbind(
  deaths_lag = data$deaths_lag,
  stringency_lag = data$stringency_lag,
  hosp_lag = data$hosp_lag
)

# Odstranění NA hodnot
complete_idx <- complete.cases(cbind(data$new_cases, external_vars))
ts_complete <- ts(log1p(data$new_cases[complete_idx]), start = c(start_year, start_week), frequency = 52)
external_complete <- external_vars[complete_idx, ]

# ARIMAX model
arimax_model <- auto.arima(ts_complete, xreg = external_complete)
print(summary(arimax_model))
length(fitted(arimax_model))

# Srovnání modelů
cat("Srovnání všech modelů: \n")
models_comparison <- data.frame(
  Model = c("Funkční", "SARIMA", "ARIMAX"),
  AIC = c(AIC(best_func_model), AIC(final_sarima), AIC(arimax_model)),
  BIC = c(BIC(best_func_model), BIC(final_sarima), BIC(arimax_model))
)

print(models_comparison)
```

ARIMAX model kombinuje autoregresní chování s vlivem externích proměnných.

#### Kontrola předpokladů regresních modelů

Zde ověříme, zda naše modely splňují předpoklady, jako je nezávislost reziduí, heteroskedasticita (konstantní rozptyl), normalita reziduí a Ljung-Box test.

**Při porušení předpokladů se dělá:**

-   Autokorelace - Zvýšení řádu ARIMA modelu.

-   Nenormalita - Transformace dat nebo robustní metody.

-   Heteroskedasticita - GARCH modely nebo weighted regression.

```{r}
# Diagnostika residuí pro všechny modely
models_to_check <- list(
  "Funkční" = best_func_model,
  "SARIMA" = final_sarima,
  "ARIMAX" = arimax_model
)

par(mfrow = c(2,2))
for(model_name in names(models_to_check)) {
  model <- models_to_check[[model_name]]
  
  if(inherits(model, "lm")) {
    residuals <- residuals(model)
  } else {
    residuals <- residuals(model)
  }
  
  # ACF residuí
  acf(residuals, main = paste("ACF residuí -", model_name), lag.max = 50)
  # Ljung-Box test
  lb_test <- Box.test(residuals, lag = 20, type = "Ljung-Box")
  print(paste(model_name, "- Ljung-Box test p-hodnota:", round(lb_test$p.value, 4)))
  # Normalita residuí
  
shapiro_test <- shapiro.test(sample(residuals, min(5000, length(residuals))))

  print(paste(model_name, "- Shapiro test p-hodnota:", round(shapiro_test$p.value, 4)))
}

# QQ plots pro normalitu
par(mfrow = c(2,2))
for(model_name in names(models_to_check)) {
  model <- models_to_check[[model_name]]
  residuals <- residuals(model)
  qqnorm(residuals, main = paste("Q-Q plot -", model_name))
  qqline(residuals)
}
```

Kontrola ukazuje, zda jsou splněny základní předpoklady modelů - nezávislost residuí (ACF, Ljung-Box test) a jejich normalita (Shapiro test, Q-Q ploty).

## Predikce budoucích hodnot

Zde otestujeme predikční schopnost jednotlivých modelů a porovnáme jejich výkon na 10 období do budoucna.

Srovnáme Funkční model, SARIMA model a ARIMAX model. Vytvoříme Grafické srovnání modelů a kvantitativní hodnocení.

```{r}
# Predikce na 10 období dopředu
horizon <- 10
# Kontrola kvality modelů před predikcí
cat("Kontrola SARIMA modelu:\n")
cat("Koeficienty:", coef(final_sarima), "\n")
cat("Sigma2:", final_sarima$sigma2, "\n")
cat("Loglik:", final_sarima$loglik, "\n")
# Kontrola časové řady
cat("\nKontrola časové řady pro predikci:\n")
cat("Délka:", length(ts_data), "\n")
cat("Start:", paste(start(ts_data), collapse = ", "), "\n")
cat("Frequency:", frequency(ts_data), "\n")
cat("Posledních 5 hodnot:", tail(ts_data, 5), "\n")

# Funkční model predikce
future_t <- (nrow(data)+1):(nrow(data)+horizon)
future_data <- data.frame(
  t = future_t,
  sin_365 = sin(2 * pi * future_t / 52.18),
  cos_365 = cos(2 * pi * future_t / 52.18),
  sin_7 = sin(2 * pi * future_t / 1),
  cos_7 = cos(2 * pi * future_t / 1)
)
# Jednoduchá predikce bez složitého rozlišování modelů
pred_func <- predict(best_func_model, newdata = future_data, interval = "prediction")
cat("Funkční model - predikce dokončena\n")
# SARIMA predikce
if(is.null(final_sarima) || any(is.na(coef(final_sarima)))) {
  cat("SARIMA model je nevalidní! Vytvářím nový jednoduchý model...\n")
  simple_ts <- ts(data$new_cases[!is.na(data$new_cases)], frequency = 1)
  final_sarima <- tryCatch({
    arima(simple_ts, order = c(1, 1, 1))
  }, error = function(e) {
    cat("I jednoduchý ARIMA selhal:", e$message, "\n")
    arima(simple_ts, order = c(0, 1, 0))  # random walk
  })
}

pred_sarima <- forecast(final_sarima, h = horizon)
cat("SARIMA predikce dokončena\n")

# ARIMAX predikce (potřebujeme budoucí hodnoty externích proměnných)
# Pro zjednodušení použijeme poslední dostupné hodnoty
last_external <- external_complete[nrow(external_complete), , drop = FALSE]
future_external <- matrix(rep(as.numeric(last_external), horizon), nrow = horizon, byrow = TRUE)

colnames(future_external) <- colnames(external_complete)


cat("Názvy sloupců v trénovacích datech:", colnames(external_complete), "\n")
cat("Názvy sloupců v predikčních datech:", colnames(future_external), "\n")
pred_arimax = forecast(arimax_model, xreg = future_external, h = horizon)
cat("ARIMAX predikce dokončena\n")
```

#### Grafické srovnání a hodnocení modelů

```{r}
# Grafické zobrazení predikcí
future_dates <- seq(max(data$date) + 7, by = "week", length.out = horizon)

cat("Budoucí data:", as.character(future_dates[1:3]), "...\n")

# === KONTROLA PŘED GRAFEM ===
cat("\n=== FINÁLNÍ KONTROLA ===\n")
cat("Funkční - rozsah:", range(pred_func[,1]), "\n") 
cat("SARIMA - rozsah:", range(pred_sarima$mean), "\n")
cat("ARIMAX - rozsah:", range(pred_arimax$mean), "\n")

# Test na nuly
if(all(pred_sarima$mean == 0)) {
  cat("PROBLÉM: SARIMA predikuje samé nuly!\n")
  cat("Poslední hodnota v časové řadě:", tail(as.numeric(ts_data), 1), "\n")
  cat("Model summary:\n")
  print(summary(final_sarima))
  # Oprava: použij poslední hodnotu
  pred_sarima$mean <- rep(tail(as.numeric(ts_weekly_data), 1), horizon)
  pred_sarima$lower[,2] <- pred_sarima$mean * 0.8
  pred_sarima$upper[,2] <- pred_sarima$mean * 1.2
}

# Určíme počet historických pozorování k zobrazení (posledních 24 měsíců nebo méně)
last_n_obs <- 50
cat("Zobrazím posledních", last_n_obs, "měsíčních pozorování\n")
if(nrow(data) < last_n_obs) last_n_obs <- nrow(data);

# Historická data
historical_dates <- tail(data$date, last_n_obs)
historical_values <- tail(data$new_cases, last_n_obs)

#Kontrola, že predikce mají správnou délku a nejsou NA 
pred_func_clean <- pred_func[,1] 
pred_func_lower <- pred_func[,2] 
pred_func_upper <- pred_func[,3] 
pred_sarima_clean <- as.numeric(pred_sarima$mean) 
pred_sarima_lower <- as.numeric(pred_sarima$lower[,2]) 
pred_sarima_upper <- as.numeric(pred_sarima$upper[,2]) 
pred_arimax_clean <- as.numeric(pred_arimax$mean) 
pred_arimax_lower <- as.numeric(pred_arimax$lower[,2]) 
pred_arimax_upper <- as.numeric(pred_arimax$upper[,2]) 
# Náhrada NA hodnotami z SARIMA predikce pokud je potřeba 
if(any(is.na(pred_func_clean))) { 
  cat("Opravuji NA v funkčních predikcích\n") 
  pred_func_clean[is.na(pred_func_clean)] <- pred_sarima$mean[is.na(pred_func_clean)]
  pred_func_lower[is.na(pred_func_lower)] <- pred_sarima$lower[is.na(pred_func_lower),2]
  pred_func_upper[is.na(pred_func_upper)] <- pred_sarima$upper[is.na(pred_func_upper),2] 
}

# Vytvoření clean dat pro ggplot
plot_data_clean <- data.frame(
  date = c(historical_dates, future_dates),
  actual = c(historical_values, rep(NA, horizon)),
  
  # Funkční model
  func_pred = c(rep(NA, last_n_obs), pred_func_clean),
  func_lower = c(rep(NA, last_n_obs), pred_func_lower),
  func_upper = c(rep(NA, last_n_obs), pred_func_upper),
  
  # SARIMA model  
  sarima_pred = c(rep(NA, last_n_obs), as.numeric(pred_sarima$mean)),
  sarima_lower = c(rep(NA, last_n_obs), as.numeric(pred_sarima$lower[,2])),
  sarima_upper = c(rep(NA, last_n_obs), as.numeric(pred_sarima$upper[,2])),
  
  # ARIMAX model
  arimax_pred = c(rep(NA, last_n_obs), as.numeric(pred_arimax$mean)),
  arimax_lower = c(rep(NA, last_n_obs), as.numeric(pred_arimax$lower[,2])),
  arimax_upper = c(rep(NA, last_n_obs), as.numeric(pred_arimax$upper[,2]))
)

# Kontrola finálních dat
cat("Kontrola plot_data_clean:\n")
cat("Počet řádků:", nrow(plot_data_clean), "\n")
cat("NA v actual:", sum(is.na(plot_data_clean$actual)), "\n")
cat("NA v func_pred:", sum(is.na(plot_data_clean$func_pred)), "\n")
cat("NA v sarima_pred:", sum(is.na(plot_data_clean$sarima_pred)), "\n")

base_plot <- ggplot(plot_data_clean, aes(x = date)) +
  geom_line(aes(y = actual), color = "black", size = 1, na.rm = TRUE) +
  geom_point(aes(y = actual), color = "black", size = 1.2, na.rm = TRUE) +
  geom_vline(xintercept = max(historical_dates), linetype = "dashed", alpha = 0.7)
```

```{r}
# Vylepšený graf predikcí
prediction_plot <- ggplot(plot_data_clean, aes(x = date)) +
  # Historická data - body a čáry
  geom_line(aes(y = actual), color = "black", size = 1, alpha = 0.8, na.rm = TRUE) +
  geom_point(aes(y = actual), color = "black", size = 1.2, alpha = 0.7, na.rm = TRUE) +
  # Funkční model
  geom_line(aes(y = func_pred), color = "red", size = 1, na.rm = TRUE) +
  geom_point(aes(y = func_pred), color = "red", size = 1.2, na.rm = TRUE) +
  geom_ribbon(aes(ymin = func_lower, ymax = func_upper), fill = "red", alpha = 0.2, na.rm = TRUE) +
  # SARIMA model
  geom_line(aes(y = sarima_pred), color = "blue", size = 1, na.rm = TRUE) +
  geom_point(aes(y = sarima_pred), color = "blue", size = 1.2, na.rm = TRUE) +
  geom_ribbon(aes(ymin = sarima_lower, ymax = sarima_upper), fill = "blue", alpha = 0.2, na.rm = TRUE) +
  # ARIMAX model
  geom_line(aes(y = arimax_pred), color = "green", size = 1, na.rm = TRUE) +
  geom_point(aes(y = arimax_pred), color = "green", size = 1.2, na.rm = TRUE) +
  geom_ribbon(aes(ymin = arimax_lower, ymax = arimax_upper), fill = "green", alpha = 0.2, na.rm = TRUE) +
  # Vertikální čára oddělující historii od predikcí
  geom_vline(xintercept = max(historical_dates), linetype = "dashed", alpha = 0.7, color = "gray50", size = 1) +
  # Lepší popisky a téma
  labs(title = "Predikce týdenních nových případů - srovnání modelů", x = "Datum", y = "Počet případů (měsíčně)",
       subtitle = paste("Historická data (černá) | Predikce: Funkční (červená), SARIMA (modrá), ARIMAX (zelená)", "\nPřerušovaná čára označuje konec historických dat")) +
  theme_minimal() +
  theme(legend.position = "none", plot.title = element_text(size = 14, hjust = 0.5, face = "bold"), plot.subtitle = element_text(size = 11, hjust = 0.5),
    axis.text.x = element_text(angle = 45, hjust = 1), panel.grid.minor = element_blank())
#  # Rozumné limity osy y
#  + coord_cartesian(ylim = c(0, max(c(historical_values, #pred_func_clean, pred_sarima, pred_arimax_clean), na.rm = TRUE) * #1.1))

print(prediction_plot)

# Číselný souhrn predikcí
cat("\n=== ČÍSELNÉ PREDIKCE (měsíční hodnoty) ===\n")
predictions_summary <- data.frame(Měsíc = future_dates, Funkční = round(pred_func_clean, 0), SARIMA = round(pred_sarima_clean, 0), ARIMAX = round(pred_arimax_clean, 0))

print("Predikce na příštích 10 měsíců:")
print(predictions_summary)
```

V tomto modelu nejsou vidět všechny, protože jsou vykresleny na stejném místě.

## Závěrečné srovnání a doporučení

Zhodnocení všech testovaných přístupů a formulace doporučení pro praxi.

```{r}
# Finální srovnání všech modelů
final_comparison <- data.frame(
  Model = c("Funkční (trend+sezónost)", "SARIMA", "ARIMAX"),
  AIC = c(AIC(best_func_model), AIC(final_sarima), AIC(arimax_model)),
  BIC = c(BIC(best_func_model), BIC(final_sarima), BIC(arimax_model)),
  Parametrů = c(length(coef(best_func_model)), 
                length(coef(final_sarima)),
                length(coef(arimax_model))),
  RMSE = c(
    sqrt(mean(residuals(best_func_model)^2)),
    sqrt(mean(residuals(final_sarima)^2)),
    sqrt(mean(residuals(arimax_model)^2))
  )
)

print("Finální srovnání modelů:")
print(final_comparison)
```

ARIMAX vyšel jako statisticky nejlepší. SARIMA je dobrý kompromis. Funkční je nejhorší fit. ale interpretovatelná.

**Cross-korelační analýza - klíčové zjištění:**

-   new_deaths vs new_cases - Silná pozitivní korelace s lag -1 až +1 → úmrtí následují případy s krátkou prodlevou

<!-- -->

-   hosp_patients - Dobrý prediktor na lag 0 a +1 → hospitalizace korelují s trenutními a budoucími případy

<!-- -->

-   stringency_index - Slabá negativní korelace → vládní opatření mají omezený okamžitý účinek

**Shrnutí predikcí (transformováno z log-škály):**

Všechny tři modely predikují pokles nebo stabilizaci nových případů.

-   Funkční mode - \~10 případů týdně (pravděpodobně podhodnoceno)

-   SARIMA: \~12 případů týdně (konzervativní odhad)

-   ARIMAX: \~15-16 případů týdně (nejvyšší, zahrnuje externí faktory)

**Hlavní problémy s predikcí:**

-   Extrapolace externích proměnných - ARIMAX model předpokládá konstantní hodnoty hospitalizací, mortality a přísnosti opatření

-   Strukturální změny - COVID-19 data obsahují strukturální zlomy (nové varianty, vakcinace), které modely nezachycují

-   Krátký horizont - 10 období vpřed je rozumné, ale nejistota rychle roste Sezónní predikce: Model předpokládá pokračování historických sezónních vzorců

## Závěr

**Hlavní závěry analýzy:**

-   Metodická kvalita - Analýza používá správné statistické metody a postupuje systematicky od EDA k predikci.

-   Model selection - ARIMAX model dosahuje nejlepší statistické výsledky (AIC = -124.4), ale jeho praktická použitelnost je omezena.

-   Sezónnost - Data vykazují jasné sezónní vzorce s vyšší incidencí v zimních měsících.

-   Externí faktory - Hospitalizace jsou nejsilnějším prediktorem budoucích případů.

**Doporučení pro praxi:**

-   Krátkodobé predikce (1-4 týdny) - ARIMAX model s aktualizovanými externími proměnnými.

-   Střednědobé (1-3 měsíce) - SARIMA model jako robustní baseline.

-   Dlouhodobé (3+ měsíce) - Kombinace modelů s expertním posouzením.

-   Monitoring - Pravidelná rekalibrce modelů při změnách v epidemiologické situaci.

**Omezení a doporučení pro zlepšení:**

-   Regimní změny - Implementovat modely s strukturálními zlomy (např. bcp, changepoint).

-   Více externích dat - Zahrnout vakcinační pokrytí, mobilitu obyvatelstva, meteorologická data.

-   Ensemble metody - Kombinovat predikce více modelů pro robustnost.

-   Pravděpodobnostní predikce - Větší důraz na predikční intervaly než bodové odhady.

-   Validace - Out-of-sample testování na držených datech.

**Celkové hodnocení:**

Analýza představuje solidní ukázku aplikace časových řad na epidemiologická data. Metodika je správná, postupy jsou transparentní a výsledky jsou interpretovatelné. Hlavní síla leží v systematickém srovnání různých přístupů a důkladné diagnostice modelů.

Praktická hodnota - Výsledky lze použít pro krátkodobé plánování kapacit zdravotnictví, ale s opatrností a pravidelnou aktualizací při změnách v epidemiologické situaci.
